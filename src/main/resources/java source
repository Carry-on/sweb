# MyBatis
## 1、#{}和${}的区别是什么？
1.#{}是预编译处理，${}是字符串替换
2.MyBatis在处理#{}时，会将sql中的#{}替换为？号，调用PreparedStatement的set方法来赋值，Mybatis在处理${}时，就是把${}替换成变量的值，使用#{}可以有效防止sql注入，提高系统安全性。

## 2.当实体类中的属性名和表中的字段名不一样 ，怎么办 ？
1.通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名相同。
2.通过<resultMap>来映射字段名和实体类属性名的一一对应关系。用id属性来映射主键字段，用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性

## 3.模糊查询like 语句该怎么写?
1.在Java代码中添加sql通配符，`String str = "%"+likeName+"%"`
2.在sql语句中拼接通配符，会引起sql注入
3.Mybatis3和Mybatis plus中提供like相关的方法，可以直接使用

## 4.通常一个Xml 映射文件，都会写一个Dao 接口与之对应，请问，这个Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗
Dao接口也就是Mapper接口。接口的全限定名，就是xml映射文件中的namespace的值；接口的方法名，就是映射文件中的Mapper的Statement的id值；接口方法内的参数，就是传给sql的参数。
Mapper接口没有实现类，当调用接口方法时，接口的全限定名+方法名拼接的字符串作为key，可以唯一定位一个MapperStatement。
Mapper接口里的方法是不能重载的，因为使用了全限定名+方法名保存和查找sql的策略。Mapper接口的工作原理是JDK的动态代理，MyBatis运行时会使用JDK动态代理为Mapper接口生成代理对象，代理对象会拦截接口方法，然后执行MapperStatement所代表的sql，然后将sql执行接口返回。

## 5.Mybatis 是如何进行分页的？分页插件的原理是什么？
Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集的内存分页。而不是物理分页。可以说在sql内直接书写带物理分页的参数来完成物理分页，也可以使用分页插件来完成物理分页。
分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法里拦截待执行的sql，然后重写sql，添加对应的物理分页语句和物理分页参数。

## 6.Mybatis 是如何将sql 执行结果封装为目标对象并返回的？都有哪些映射形式？
1.使用<resultMap>标签，逐一定义数据库列名和对象属性名之间的映射关系
2.使用sql的别名功能，将列的别名书写成对象的属性名，有了列名和属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性注意赋值并返回，哪些找不到映射关系的属性，是无法赋值的。

## 7.在 mapper 中如何传递多个参数?
1.在Dao接口的方法中传多个参数，对应的xml，#{0}代表接收的是dao方法的第一个参数，#{1}代表dao方法的第二个参数，以此类推
2.使用@param注解，
3.多个参数封装成一个map，在xml里通过key来获取

## 8.Mybatis 动态sql 有什么用？执行原理？有哪些动态sql？
Mybatis动态sql可以在xml映射文件中，以标签的形式编写动态sql，执行原理是根据表达式的值，完成逻辑判断并动态拼接sql的功能。
Mybatis提供了9种动态sql标签：if|foreach|where|choose|when|otherwise|trim|set|bind.

## 9.一对一，一对多关联查询？
1.一对一关联查询，添加一个resultMap标签，resultMap标签里添加一个association标签，association标签里都是关联表的所有属性。
2.一对多关联查询，添加一个resultMap标签，resultMap标签里添加一个collection标签，collection标签里都是关联表的所有属性。

## 10.Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？
MyBatis仅支持association关联对象和collection关联集合对象的延迟加载，在Mybatis配置文件种可以配置是否启用延迟加载，lazyLoadingEnable=true|false。
延迟加载的原理是，使用CGLIB创建目标对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName()，拦截器invoke()方法发现 a.getB()是null，那么就会单独发送事先保存好的关联查询 B对象的sql，把 B查询出来，然后再调用 a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法调用。

----

# Redis
## 1.Redis优势？
性能极高-Redis读的速度能达到十几万次每秒，写的速度能达到8万多次每秒。
丰富的数据类型-Redis支持String，List，Hash，Set，Ordered Set，HyperLogLog，bitmap，Geo。
原子操作-Redis的所有操作都是原子性的，多个操作也支持事务，通过Multi和exec指令包起来。
Redis支持publish/subscribe，通知，key过期，数据备份，master-slave
数据持久化

## 2.Redis的持久化机制是什么？各有什么特点？
Redis提供两种持久化机制，RDB和AOF机制
1.RDB（Redis DataBase）：用数据集快照的方式半持久化模式，记录redis数据库的所有键值对，再某个时间点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复。
优点：
- 只有一个文件dump.rdb，方便持久化。
- 容灾性好，一个文件可以保存到安全的磁盘。
- 性能最大化，fork子进程来完成写操作，让主线程继续处理命令，所以IO最大化，使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证了redis的高性能。
- 相对于数据集大时，比AOF的启动效率更高。
缺点：
- 数据安全性低。RDB时间隔一段时间进行持久化，如果持久化之间redis发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候。

2.AOF(Append-only file)：所有的命令行记录以redis命令请求协议的格式完成持久化存储，保存为aof文件。
优点：
- 数据安全，aof持久化可以配置appendfsync属性，有always，每进行一次命令操作就记录到aof文件中一次。
- 通过append模式写文件，即使中途服务器宕机，也可以通过redis-check-aof工具解决数据一致性问题。
- AOF机制的rewrite模式。AOF文件没被rewrite之前（文件过大时会对命令进行整合并重写），可以删除其中的某些命令（比如误操作的flushall）
缺点：
- AOF文件比RDB文件大，且恢复速度慢。
- 数据集大的时候，比RDB启动效率低。

## 3.redis过期键删除策略？
1. 定时删除：在设置键的过期时间的同时，创建一个定时任务timer，让定时器在过期时间来临时，立即执行对键的删除操作。
2. 惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除键，没有过期的话，就返回该键。
3. 定期删除：每隔一段时间程序就对数据库进行一次检查，删除里面的过期键，至于要删除多少过期键，以及要检查多少个数据库，由算法决定。

## 4.redis内存回收策略（淘汰机制）？
- volatile-lru：从设置过期时间的数据集中挑选最近最少使用的数据淘汰
- volatile-ttl：从设置过期时间的数据集中挑选要过期的数据淘汰
- volatile-random：从设置过期时间的数据集中任意选择数据淘汰
- allkeys-lru：从数据集中挑选最近最少使用的数据淘汰
- allkeys-random：从数据集中任意选择数据淘汰
- no-enviction：禁止驱逐数据
使用策略规则：
1. 如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用allkeys-lru
2. 如果数据呈现平等分布，也就是数据访问频率都相同，则使用allkeys-random

## 5.redis同步机制
Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，在通知主节点将期间修改的操作记录同步到复制节点，进行重放。

## 6.Pipeline有什么好处，为什么要用pipeline？
可以将多次IO往返的时间缩减为一次，前提时pipeline执行的指令之间没有因果关系。可以提高QPS

## 7.redis如何做内存优化？
尽量使用散列表hash，散列表使用的内存非常小（散列表里面存储的数少），所以尽可能的将数据模型抽象到一个散列表中。

----

# MySQL
## 1.MySQL有哪几种锁？
1. 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率高，并发度最低。
2. 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生所冲突的概率最低，并发度也最高。
3. 页面锁：开销和加锁时间介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般。

## 2.MySQL中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？
1. read uncommited： 读到未提交数据
2. read commited： 脏读，不可重复读
3. repeatable read：可重复读，幻读
4. serializable： 串行事务

## 3.MySQL设计优化
1. 设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。
2. 选择合适的字段数据类型和存储引擎，适当的添加索引。
3. MySQL库主从读写分离。
4. 找规律分表，减少表单中的数据量，提高查询速度。
5. 添加缓存机制，比如redis，memcached
6. 不经常改动的页面，生成静态页面。
7. 书写高效率SQL。

## 4.什么情况下设置了索引但无法使用
1. 以“%”开头的like语句
2. or 语句前后没有同时使用索引
3. 数据类型出现隐式转换（如varchar不加引号可能转换成int）

## 5.实践中如何优化MySQL？
1. SQL语句及索引的优化
2. 数据库表结构的优化
3. 系统配置的优化
4. 硬件优化
5. 架构的优化

## 6.优化数据库的方法？
1. 选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置为 not null， 例如 省份，性别最好适用ENUM。
2. 使用join来代替子查询。
3. 使用联合（union）来代替手动创建临时表
4. 锁定表，优化事务处理
5. 使用外键，优化锁定表
6. 建立索引，并合理使用索引
7. 优化查询语句

## 7.SQL语句优化方法
1. where子句中，where表之间的连接必须写在其他where条件之前，那些可以过滤掉最大数量记录的条件必须写在where子句的末尾，having的最后。
2. 用exists替代in，用not exists替代not in。
3. 避免索引失效，避免在索引上计算，避免在索引上使用函数（包括is null，is not null），避免在索引上出现隐式转换，避免在索引上使用%开头的like语句。
4. 对查询进行优化，应尽量避免全表扫描，首先应考虑在where和order by涉及的字段上建立索引。

----

# Java并发
## 1.乐观锁和悲观锁
悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到这个锁。
乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在次期间别人有没有去更新这个数据，可以使用版本号控制解决ABA问题
CAS的缺点：
1.ABA问题
2.循环时间长开销大，对于资源竞争严重（线程冲突严重）的情况，cas自旋的概率会比较大，从而浪费更多cpu资源，效率低于syhchronized
3.只能保证一个共享变量的原子操作。



# Spring

## 1.Spring事务传播机制
1. propagation_required(默认)
支持当前事务，如果当前没有事务，则新建一个事务，如果当前存在事务，则加入当前事务，合并成一个事务。
2. requires_new
新建事务，如果当前存在事务，则把当前事务挂起，这个方法会独立提交事务，不受调用者的事务影响，父级异常也能正常提交。
3. nested
如果当前存在事务，它将会成为父级事务的一个子事务，方法结束后并没有提交，只有等待父事务结束才提交。如果当前没有事务，则新建事务。如果它异常，父级可以捕获它的异常二不进行回滚，正常提交，如果父级异常，它必然回滚。
4. supports
如果当前存在事务，则加入事务，如果当前不存在事务，则以非事务的方式运行。
5. not_supported
以非事务方式运行，如果当前存在事务，则把事务挂起。
6. mandatory
如果当前存在事务，则运行在当前事务中，如果当前没有事务，则抛出异常，也即父级方法必须有事务。
7. never
以非事务方式运行，如果当前存在事务，测抛出异常，即父级方法必须无事务。

# Spring Cloud
## 1.Spring Cloud断路器的作用是什么？
在分布式架构中，路断器模式的作用也是类似的，当某个服务单元发生故障（类似于电器短路）之后，通过路断器的故障监控，向调用方返回一个错误相应，而不是长时间等待。这样就不会使得调用线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。

## 2. Spring Cloud的核心组件
- Eureka：服务注册和发现
- Feign：基于动态代理机制，根据注释和选择的机器，拼接请求的URL地址，发起请求。
- Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。
- Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。
- Zuul：网关管理，由Zuul网关转发请求给对应的服务。

## 3.微服务之间是如何独立通讯的？
- 远程调用：也就是常说的服务注册和发现，直接通过远程过程调用来访问别的service。
优点：简单，常见，因为没有中间件代理，系统简单
缺点：只支持请求/响应的模式，降低了可用性，因为客户端和服务端在请求过程中都是可用的。
- 消息：使用异步消息来做服务间通信。服务间通过消息管道来交换信息，从而通信。

## 4.Spring Cloud如何实现服务注册？
1. 服务发布时，指定对应的服务名，将服务注册到注册中心（eureka，zookeeper）
2. 注册中心加@EnableEurekaServer，服务用@EnableDiscoveryClient，然后用ribbon或feign进行服务直接调用发现

## 5.微服务技术栈
- 服务开发：springboot spring springmvc
- 服务配置与管理：Archaiusm，Diamond
- 服务注册与发现：Eureka，Zookeeper，Nacos
- 服务调用： Rest，RPC，gRPC
- 服务熔断器：Hystrix
- 服务负载均衡：Ribbon，Nginx
- 消息队列：Kafka，RabbitMQ，ActiveMQ
- 服务配置中心：Spring Cloud Config，Nacos
- 服务路由（API网关）：Zuul
- 事件消息总线：Spring Cloud Bus

## 6.Eurake和Zookeeper的区别
1. Zookeeper保证CP，Eurake保证AP
Zookeeper在选举期间注册服务瘫痪，虽然服务最终会恢复，但是选举期间不可用
Eurake各个节点时平等关系，只要有一台Eurake就可以保证服务可用，而查询到的数据并不是最新的
自我保护机制会导致
Eurake不再从注册列表移除因产时间没收到心跳而应该过期的服务
Eurake仍然能够接受新服务的注册和查询请求，但是不会被同步到其他节点（高可用）
当网络稳定时，当前实例新的注册信息会被同步到其他节点（最终一致性）
Eurake可以很好的应对因网络故障导致部分节点数去联系的情况，而不会像Zookeeper一样使得整个注册系统瘫痪。
2. Zookeeper由Leader和Follower角色，Eurake各个节点平等。
3. Zookeeper采用过半存活原则，Eurake采用自我保护机制解决分区问题。
4. Eurake本质上是一个工程，Zookeeper只是一个进程。

## 7.什么是Feign？它的优点是什么？
1. feign采用的是基于接口的注解
2. feign整合了ribbon，具有负载均衡的能力
3. 整合了Hystrix，具有熔断能力
使用：
1. 添加pom依赖
2. 启动类上添加@EnableFeignClients
3. 定义一个接口@FeignClient(name="xxx")指定调用哪个服务

## 8.Ribbon和Feign的区别
1. Ribbon和Feign都是调用其他服务，但是方式不同
2. 启动类注解不同，Ribbon是@RibbonClient，Feign是@EnableFeignClients
3. 服务指定的位置不同，Ribbon是在@RibbonClient注解上声明，Feign则是在定义抽象方法的接口上使用@FeignClient声明
4. 调用方式不同，Ribbon需要自己构建http请求，模拟http请求然后使用RestTemplate发送给其他服务，步骤相当繁琐。Feign需要将调用方法定义成抽象方法即可。


# 网络

## 1.OSI七层协议
1. 物理层
负责将信息编码成电流脉冲或其他信号用于网上传输。它由计算机和网络介质之间的实际界面组成，可以定义电气信号，符号，线的状态和时钟要求，数据编码和数据传输用的连接器。
2. 数据链路层
数据链路层通过物理网络链路提供可靠的数据传输。不同的数据链路层定义了不同的网络和协议特征，其中包括物理编址，网络拓扑结构，错误校验，帧序列以及流控。物理编址（相对应的网络编址）定义了设备在数据链路层的编址方式；网络拓扑结构定义了设备的物理连接方式，如总线拓扑和环拓扑结构；错误校验向发生传输错误的上层协议告警；数据帧序列重新整理并传输除序列以外的帧；流控可能延缓数据的传输，以使接收设备不会因为在某一时刻接收到超过其处理能力的信息流而崩溃。
数据链路层实际上由连个独立的部分组成，介质存储控制（Media Access Control， MAC）和逻辑链路控制层（Logical Link Control， LLC）。MAC描述在共享介质环境中如何进行站的调度，发送和接收数据。MAC确保信息跨链路的可靠传输，对数据传输进行同步，识别错误和控制数据的流向。IEEE MAC规则定义了地址，以标识数据链路中的多个设备。逻辑链路控制层管理的那一网络链路上的设备间的通信。 LLC支持无法连接服务和面向连接的服务。在数据链路层的信息帧中定义了许多域。这些域使得多种高层协议可以共享一个数据链路层。
3. 网络层
网络层负责在源和终点之间简历连接。它一般包括网络寻址，还可能包括流量控制，错误检查等。相同MAC标准的不同网段之间的数据传输一般只涉及到数据链路层，而不同的MAC标准之间的数据传输都涉及到网络层。例如IP路由器工作在网络层，因而可以实现多种网络间的互联。
4. 传输层
传输层向高层提供可靠的端到端的网络数据流服务。传输层的功能包括流控，多路传输，虚电路管理以及差错校验和恢复。流控管理设备之间的数据传输，确保传输设备不发送比接收比设备处理能力大的数据；多路传输使得多个应用程序的数据可以传输到一个数据链路上；虚电路由传输层建立，维护和终止；差错校验包括为检测传输错误而建立的各种结构；而差错恢复包括所采取的行动（如请求数据重发），以便解决发生的任何错误。
5. 会话层
会话建立，管理，和终止表示层语实体之间的通信会话。通信会话包括发生在不同网络应用层之间的请求服务和服务应答。它还包括创建检查点，是通信发生中断的时候可以返回到以前的一个状态。
6. 表示层
表示层提供多种功能用于应用层数据编码和转化，以确保一个系统应用层发送的信息可以被另一个系统应用层识别。表示层的编码和转化模式包括公用数据表示格式，性能转化表示格式，公用数据压缩模式和公用数据加密模式。
7. 应用层
应用层是最接近终端用户的OSI层，这意味着OSI应用层与用户之间是通过应用软件之间相互作用的。应用层的功能一般包括标识通信伙伴，定义资源的可用性和同步通信

## 2.TCP/IP四层参考模型
1. 数据链路层
数据链路层实现了网卡接口的网络驱动程序，以处理数据在物理媒介（以太网，令牌环）上的传输。
数据链路层有两个常用的协议ARP协议（Address Resolve Protocol，地址解析协议）和RARP协议（Reverse Address Resolve Protocol，逆地址解析协议）。他们实现了IP地址和机器物理地址（通常是MAC地址，以太网，令牌环和802.11，无线网络都使用MAC地址）之间的相互转换。
网络层使用IP地址寻址一台机器，而数据链路层使用物理地址寻址一台机器，因此网络层必须先将目标机器的IP地址转化成其物理地址，才能使用数据链路层提供的服务，这就是ARP协议的用途。
2. 网络层
网络层实现数据包的选路和转发。
WAN（Wide Area NetWork，广域网）通常使用众多分级路由器来连接分散的主机或者LAN（Local Area Network，局域网），因此，通信的两台主机一般不是直接相连的，而是通过多个中间节点（路由器）连接的。网络层的任务就是选择这些中间节点，以确定两台主机之间的通信路径。同时网络层对上层协议隐藏了网络拓扑连接的细节，使得在传输层和网络应用程序看来，通信双方是直接连接的。
网络层最核心和协议是IP协议（Internet Protocol，英特网协议）。IP协议根据数据包的目的IP地址来决定如何投递它。如果数据包不能直接发送给目标主机，那么IP协议就为它寻找一个合适的下一跳（next hop）路由器，并将数据包交付给该路由器来分发。多次重复这一过程，数据包最终到达目标主机，或者由于发送失败而丢弃。
网络层另外一个重要协议是ICMP协议（Internet Control Message Protocol，因特网控制报文协议）。它是IP协议的重要补充，主要用于检查网络连接。
3. 传输层
传输层为两台主机上的应用程序提供端到端（end to end）的通信。与网络使用的逐跳通信方式不同，传输层只关心通信的起始端和目的端，而不在乎数据包的中转。
数据链路层（驱动程序）封装了物理网络的电气细节；网络层封装了网络连接的细节；传输层则为应用程序封装了一条端到端的逻辑通信链路，它负责数据的收发，链路的超时重连。
- TCP协议（Transmission Control Protocol,传输控制协议）为应用层提供可靠的，面向连接和基于流（stream）的服务。TCP协议使用超时重传，数据确认等方式来确保数据包被正确的发送到目的端，因此TCP服务是可靠的。使用TCP协议通信的双方必须先建立TCP连接，并在内核中为该连接维持一些必要的数据结构，比如连接的状态，读写缓冲区，以及诸多定时器等，当通信结束时，双方必须关闭连接以释放这些内核数据。TCP服务时基于流的。基于流的数据没有边界（长度）限制，它源源不断地从通信的一端流入另一端。发送端可以逐个字节地向数据流中写入数据，接收端也可以逐个字节地将他们读出。
- UDP协议（User Datagram Protocol，用户数据报协议），它为应用提供不可靠，无连接和基于数据报的服务。“不可靠”意味着UDP协议无法保证数据从大宋段正确地传送到目的段。如果数据在中途丢失，或者目的端通过数据校验发现数据错误而将其丢弃，则UDP协议只是简单的通知应用程序发送失败。因此，使用UDP协议地应用程序要自己处理数据确认，超时重传等逻辑。UDP协议是无连接地，即通信双方不保持一个长久的联系，因此应用程序每次发送数据都要指定接收端的地址（IP地址）。基于数据报的服务，是相对基于流的服务而言，每个UDP数据报都有一个长度，接收端必须以该长度为最小单位将其所有内容一次性读出，否则数据将被截断。
4. 应用层
应用层负责处理应用程序的逻辑。
数据链路层，网络层和传输层负责处理网络通信细节，这部分不惜既稳定又高效，因此他们都在内核空间中实现。而应用层则在用户空间实现，因为他负责处理众多逻辑，比如文件传输，名称查询和网络管理等。


